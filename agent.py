"""
agent.py

LangChain agent setup with Mem0-based persistent memory integration.

This module is responsible for:
- Initializing a LangChain agent with tool support
- Retrieving relevant user memories from Mem0
- Injecting memory context into the system prompt
- Persisting conversation turns for long-term personalization

The design follows a stateless agent invocation pattern while enabling
stateful behavior through external memory storage (Mem0).
"""

from typing import Dict, List

from langchain.agents import create_agent
from langchain_core.messages import SystemMessage

from client import model, mem0
from prompt import system_prompt
from tools import math_calculator, date_utility_tool, get_weather, analyze_text
from logger_config import setup_logger

logger = setup_logger(__name__)

logger.info("Initializing LangChain agent with Mem0 memory")

# Register all agent tools
tools = [math_calculator, date_utility_tool, get_weather, analyze_text]
logger.debug(f"Registered tools: {[tool.name for tool in tools]}")


def retrieve_memories(query: str, user_id: str) -> str:
    """
    Retrieve relevant long-term memories for a given user query.

    This function queries the Mem0 memory store to fetch past interactions
    associated with the specified user that are semantically relevant to
    the current query. Memory retrieval is skipped for very short queries
    (e.g., greetings) to reduce noise and latency.

    Args:
        query (str): The user's current input query.
        user_id (str): Unique identifier for the user whose memories
            should be searched.

    Returns:
        str: A serialized bullet-point string of relevant memories.
        Returns an empty string if:
        - The query is shorter than 3 words
        - No relevant memories are found
        - An error occurs during retrieval
    """
    logger.info(f"Retrieving memories for user: {user_id}")

    # Skip memory retrieval for greetings or very short inputs
    if len(query.strip().split()) < 3:
        return ""

    try:
        memories = mem0.search(
            query=query,
            filters={"user_id": user_id},
            limit=5,
        )

        memory_list = memories.get("results", [])
        if not memory_list:
            return ""

        serialized_memories = "\n".join(
            f"- {mem['memory']}" for mem in memory_list
        )

        logger.info(f"Retrieved {len(memory_list)} memories")
        return serialized_memories

    except Exception as exc:
        logger.error(
            f"Error retrieving memories for user {user_id}: {exc}",
            exc_info=True,
        )
        return ""


def save_interaction(
    user_id: str,
    user_input: str,
    assistant_response: str,
) -> None:
    """
    Persist a single conversation turn to Mem0.

    This function stores both the user's input and the assistant's response
    as a single interaction in Mem0, enabling future personalization and
    contextual recall across sessions.

    Args:
        user_id (str): Unique identifier for the user.
        user_input (str): Raw input text provided by the user.
        assistant_response (str): Final response generated by the agent.

    Returns:
        None
    """
    logger.info(f"Saving interaction to Mem0 for user: {user_id}")

    try:
        interaction = [
            {"role": "user", "content": user_input},
            {"role": "assistant", "content": assistant_response},
        ]

        result = mem0.add(interaction, user_id=user_id)
        logger.info(
            f"Memory saved successfully: "
            f"{len(result.get('results', []))} memories added"
        )

    except Exception as exc:
        logger.error(
            f"Error saving interaction to Mem0 for user {user_id}: {exc}",
            exc_info=True,
        )


def invoke_agent_with_memory(
    messages: Dict,
    user_id: str = "default_user",
) -> Dict:
    """
    Invoke the LangChain agent with memory-enhanced context.

    This function:
    1. Extracts the latest user query
    2. Retrieves relevant long-term memories from Mem0
    3. Augments the system prompt with memory context
    4. Invokes the LangChain agent
    5. Persists the interaction back to Mem0

    Args:
        messages (Dict): Dictionary containing a `messages` key with
            a list of LangChain message objects representing
            conversation history.
        user_id (str, optional): Unique identifier for memory persistence.
            Defaults to `"default_user"`.

    Returns:
        Dict: Agent response containing updated conversation messages,
        including the assistant's latest reply.

    Raises:
        Exception: Propagates any exception raised during agent invocation.
    """
    logger.info(f"Invoking agent with memory for user: {user_id}")

    # Extract latest user message
    last_message = messages["messages"][-1]
    user_query = (
        last_message.content
        if hasattr(last_message, "content")
        else str(last_message)
    )

    # Retrieve memory context
    memory_context = retrieve_memories(user_query, user_id)

    # Build enhanced system prompt
    enhanced_system_prompt = SystemMessage(
        content=f"""{system_prompt.content}

## MEMORY CONTEXT
{memory_context}

Rules:
- Use memory facts if available
- If user's name is known, use it
- Do NOT claim lack of personal context if memory exists
"""
    )

    # Replace original system prompt
    enhanced_messages = {
        "messages": [enhanced_system_prompt] + messages["messages"][1:]
    }

    try:
        response = agent.invoke(enhanced_messages)

        # Extract assistant reply
        assistant_response = response["messages"][-1].content

        # Persist interaction
        save_interaction(user_id, user_query, assistant_response)

        logger.info("Agent invocation with memory completed successfully")
        return response

    except Exception as exc:
        logger.error(
            f"Agent invocation failed for user {user_id}: {exc}",
            exc_info=True,
        )
        raise


# Initialize agent once at module load
try:
    agent = create_agent(model=model, tools=tools)
    logger.info("Agent created successfully")
except Exception as exc:
    logger.error(f"Failed to create agent: {exc}", exc_info=True)
    raise
